\section{Tools}
The problem domain dictates that the proposed solution will consist of web development and server-side scripting.
The development platform will therefore consist of two parts.
Firstly the setup including the operating system of the server must be decided, and secondly the programming language for the application must be decided.

\subsection{Server operating system}
There are two major operating system families to choose from, which each has some potential operating systems beneath them:

\begin{itemize}
    \item Windows Server family
        \begin{itemize}
            \item Windows Server 2003
            \item Windows Server 2008
            \item Windows Server 2012
        \end{itemize}
    \item UNIX family
        \begin{itemize}
            \item Linux
                \begin{itemize}
                    \item Debian/Ubuntu
                    \item Fedora
                    \item CentOS/RedHat
                    \item Various other distributions of Linux
                \end{itemize}
            \item BSD
            \item Mac OSX Server
        \end{itemize}
\end{itemize}

We have chosen to use Linux Debian due to the following reasons:

\begin{itemize}
    \item We find that the various Linux distributions are easier to use for project like these, where various web applications and server-side scripts are executed on the server. This is of course our preference, and a Windows-family server has equivalent execution power when it comes to executing web applications and similar. We have more experience with the Linux-family server operating systems, and therefore it is easier for us to deploy.
    \item It is easy to get started on the project, as installation of the programs needed is simple.
    \item Linux Debian is open-source and does not require a license to install or use.
    \item Linux Debian is one of the most well-liked operating systems amongst system administrators, credited for its maintainability, size, ease to customize and community support \citep{why_debian}. Linux Debian has a huge community that continuously updates and maintains it.
\end{itemize}

It is important to underline that any of the listed operating systems are fully capable of handling any task needed in this project.
Operating systems are often chosen based on personal preferences or experience with a given operating system.
%Deciding which operating system to use is often considered a ``religious'' choice, as different system administrates has each there preferences.
The operating system chosen for the server-side applications in \projectname{} is Linux Debian.

\subsection{Programming language}
Our choice to use Linux Debian as operating system on the servers limits the possible choices for programming languages.
Programming languages within the .NET framework are not natively written to work on other platforms than Windows Server and are therefore discarded as emulating tools such as Wine are not a reliable solution. \\

We have some requirements to the programming language that we want to use.
These are:

\begin{itemize}
    \item It must support object oriented programming
    \item It must have native MySQL libraries
    \item It must be open-source and have an active community to ensure continuous bug-fixing etc. or be a corporate language that is professionally maintained.
\end{itemize}

This leaves us with a number of options that we have narrowed down to the ones we already have little to some knowledge about or experience with.
These are:
\begin{itemize}
    \item Java
    \item Python
    \item Ruby
    \item Perl
    \item PHP
\end{itemize}

Just as when you are choosing which operating system to use, choosing which programming language to use can be considered a bit ``religious''.
All of the above are able to output a program with similar functionality that runs on a Linux Debian server.\\

The language we have chosen for \projectname{} is Ruby and the web development framework Ruby on Rails.
The reasons why we have chosen Ruby and Ruby on rails follows.
First are some of the advantages by using Ruby and Ruby on Rails:

\begin{itemize}
    \item Ruby is easy to install server-side.
    \item Ruby can be used as a server-side scripting language.
    \item Rails provide an easy-to-use framework for web-development with Ruby.
\end{itemize}

Ruby is a object oriented scripting language.
Besides working as a server-side scripting language it also works for web programming as several different web servers - e.g. Apache - has modules to support Ruby. \\

Ruby on Rails \emph{[Rails]} is a open-source web framework for Ruby optimized to make programming as easy and efficient as possible.
Rails provide a set of built-in features, such as native support for the MVC model and Active Records.
%that enables us to be more efficient and write better quality code.
Rails also has build in features that make it easier to be multiple programmers working on the same project.
An example is ``Migrations'', which is Rails' way of handling databases.
Instead of having one big shared database that each developer connects to, to make sure that everybody is always working on an updated database, Rails uses migrations to save changes to the databases.
When a developer pulls the newest revision from the repository, he is able to execute a command to run all migrations.
This will initialize a part of Rails that updates the developers local database.
If he makes some changes to the database, he simply makes a new migration document, pushes it to the repository and the rest of the team can get the updated version of the database by running the migration.\\

%This is one of the features of Rails that helped us to make the decision to use it. \\

Keeping in mind that this is a student project, Ruby is also a natural choice as we in the group have little to no knowledge of how Ruby works.
This is a great opportunity for us to lean how to use another programming language. \\

We know that we will be communicating long distance with the drone.
We define ``Long Distance'' in this context as communication between two computer devices that are not on the same LAN.
This will require some sort of server or gateway between the web application and the drone.
We also already know that we have to build some web application and server side scripting which both requires some soft of hosting.
Both aspects also work very well with Ruby and Rails.

\subsection{Streaming Tools}\label{sec:tools_streaming}
%Hvad skal vi opnå med streaming
%Hvilke tilgange kan der tages til at løse problemet
%Hvilke løsningsmuligheder findes i den valgte tilgang
%Hvilke tools er valgt og hvorfor
%Hvordan er toolsne kombineret

%Reviewer det selv inden andre skal se på det, for havde ikke meget fokus da jeg skrev det
The video feed send by the drone to \deno{S} is forwarded to the users browser as seen in Figure~\ref{fig:sequence_diagram}.
As described in Section~\ref{sec:design_client} the stream will be displayed in a Flash application.
Flash only natively supports video streams send via Real Time Messaging Protocol\textit{(RTMP)}\citep{rtmp_spec}.
The video stream send by the drone is send by TCP and it is H.264 encoded as described in Appendix~\ref{app:ar_drone_specification}.
Flash is compatible with H.264 encoded video\citep{netstream_spec}.
The drones video feed is however encoded with the unique PaVE headers, see Appendix~\ref{app:ar_drone_specification}, and must therefore be reencoded in order for the flash application to be able to read the stream.
Each \deno{S} must therefore contain functionality capable of reading and reencode the drones stream and forward it via RTMP to the Flash application running in the users browser.

As mentioned in Section~\ref{sec:design_slave} developing a streaming solution from scratch is outside the scope of the project.
The streaming is therefore to be handled using tools.
The tools must be open-source\fxfatal{Hvorfor? Noget med budget eller bare fordi vi har valgt det}.
\\

There are two streaming solution using tools.
One is using a tool capable of reading the drones video feed and broadcast a RTMP feed.
The other is one using two tools.
A tool which reads the drones feeds and forwards it to a rtmp server.
Both solution depends on a tool capable of decoding the PaVE headers.
The tools considered are the multimedia frameworks FFmpeg and Gstreamer, and the multimedia server C++ RTMP Server.

FFmpeg is a multimedia framework capable of recording and converting audio and video.
It contains a multimedia streaming server called FFserver.
FFserver is used for live broadcasts and is capable of decoding and enconding a large set of video formats.
It is however incapable of decoding the unique PaVE headers the drones video feed is encoded with.
It however capable of outputting a RTMP feed.
Therefore FFmpeg cannot be used to read the drones video feed, but can send the RTMP stream if given a proper input.

Gstreamer is multimedia framework that uses a pipeline architecture to process video and audio feeds.
A pipeline in this context is a set plugins the video feed is send through and processed by.
As an example a video feed might be deencoded and then reencoded in a new format.
Gstreamer is not capable of outputting a readable RTMP stream, as it contains no server functionality.
It is however capable of sending a video feed to a RTMP server.
Gstreamer is not natively capable of decoding PaVE header.
There does however exist a plugin for gstreamer developed by the AR Drone community which enables to properly parse the PaVE headers.
The plugin is named paveparse\citep{paveparse}.

C++ RTMP Server\textit{(CRTMP)} is a streaming server capable of streaming to and from a flash application.
It can receive a local stream send via e.g RTP and broadcast it globally as RTMP, RTMPE, RTMPS, RTMPT, and RTMPTE.

The chosen solution is to use gstreamer to read and rebroadcast the drones video feed via CRTMP.






%We have decided to use Linux Debian for this purpose, as Linux provides a lot of useful and built-in features for hosting both web applications, server side scripting and databases.
